<!DOCTYPE html>
<html lang="cn">
<head>
        <meta charset="utf-8" />
        <title>耕有田，读有书 - python</title>
        <link rel="stylesheet" href="http://forin-xyz.github.io/output/theme/css/main.css" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
<a href="http://github.com/forin-xyz/">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" />
</a>
        <header id="banner" class="body">
                <h1><a href="http://forin-xyz.github.io/output/">耕有田，读有书 </a></h1>
                <nav><ul>
                    <li><a href="http://forin-xyz.github.io/output/category/ji-qi-xue-xi.html">机器学习</a></li>
                    <li><a href="http://forin-xyz.github.io/output/category/python.html">Python</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="http://forin-xyz.github.io/output/2016/02/du-shu-bi-ji-5-po-su-bei-xie-si-fang-fa.html">《统计学习方法》读书笔记5-朴素贝叶斯方法，含python源码</a></h1>
<footer class="post-info">
        <abbr class="published" title="2016-02-19T23:00:00+08:00">
                发表于: 2016年02月19日 星期五
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="http://forin-xyz.github.io/output/author/forin-xyz.html">forin-xyz</a>
        </address>
<p>In <a href="http://forin-xyz.github.io/output/category/ji-qi-xue-xi.html">机器学习</a>.</p>
<p>tags: <a href="http://forin-xyz.github.io/output/tag/ji-qi-xue-xi.html">机器学习</a> <a href="http://forin-xyz.github.io/output/tag/po-su-bei-xie-si.html">朴素贝叶斯</a> <a href="http://forin-xyz.github.io/output/tag/naive-bayes.html">Naive Bayes</a> <a href="http://forin-xyz.github.io/output/tag/python.html">python</a> <a href="http://forin-xyz.github.io/output/tag/ji-suan-ji-ke-xue.html">计算机科学</a> <a href="http://forin-xyz.github.io/output/tag/shu-xue-yuan-li.html">数学原理</a> <a href="http://forin-xyz.github.io/output/tag/du-shu-bi-ji.html">读书笔记</a> </p>
</footer><!-- /.post-info --><h2>原理</h2>
<h3>贝叶斯定理</h3>
<p>事件A和事件B同时发生的概率等于事件B发生的概率与事件A在事件B已经发生的条件下发生的概率的乘积, 即
</p>
<div class="math">$$ P(A, B) = P(AB) = P(A|B)P(B) $$</div>
<h3>贝叶斯公式</h3>
<div class="math">$$ P(A_{i}|B) = \frac{P(B|A_{i})P(A_{i})}{P(B)} $$</div>
<p>
其中
</p>
<div class="math">$$ P(B) = \sum\limits_{i=0}{n}P(B|A_{i})P(A_{i}) $$</div>
<p>
于是
</p>
<div class="math">$$ P(A_{i}|B) = \frac{P(B|A_{i})P(A_{i})}{\sum\limits_{i=0}{n}P(B|A_{i})P(A_{i})} $$</div>
<p>
这就是贝叶斯公式, 其中<span class="math">\(\{A_{i}\}\)</span>为完备事件组,即<span class="math">\(\cup\limits_{i}A_{i} = \Omega, A_{i}A_{j} = \phi,(i \ne j), P(A_{i}) &gt; 0\)</span>.</p>
<h3>朴素贝叶斯方法的基本描述</h3>
<p>输入空间<span class="math">\(\mathcal(X) \subseteq mathrm(R)^{n}\)</span>是n维向量的几何
输出空间<span class="math">\(\mathcal(Y) = \{c_{1}, c_{2}, \cdots, c_{K}\}\)</span>是类标记组合
朴素贝叶斯方法是求特定输入下的后验概率最大化。</p>
<h3>特征条件相互独立假设</h3>
<p>朴素贝叶斯方法对条件概率分布做了互相独立的假设，即在输出一定的条件下，实例点的特征分量彼此相互独立，即：
</p>
<div class="math">$$\begin{aligned}
P(X = x|Y = c_{k}) =&amp; P(X^{1}=x^{1}, \cdots, X^{n}=x^{n}|Y=c_{k})\\
=&amp;\prod\limits_{j=1}{n}P(X^{j}=x^{j}|Y=c_{k})
\end{aligned}
$$</div>
<h3>朴素贝叶斯方法的最终推导</h3>
<p>将特征条件相互独立代入到贝叶斯公式， 有
</p>
<div class="math">$$
P(Y=c_{k}|X=x)=\frac{P(Y=c_{k})}\prod\limits_{j=1}{n}P(X^{j}=x^{j}|Y=c_{k})}{\sum_{k}{P(Y=c_k)}\prod_{j}{P(X^{j}=x^{j}|Y=c_{k})}}
$$</div>
<p>
朴素贝叶斯分类器就是选取在给定的输入的情况下，将后验概率最大的类最为输出的分类的方法，又
由于分子对于每一个给定的<span class="math">\(c_{k}\)</span>是相同的,于是
</p>
<div class="math">$$
y = \arg\max\limits_{c_{k}}{P(Y=c_{k})}\prod\limits_{j=1}{n}{P(X^{j}=x^{j}|Y=c_{k})}
$$</div>
<p>
就是朴素贝叶斯分类器的最终模式。</p>
<h3>后验概率最大化的意义</h3>
<p>朴素贝叶斯方法将实例分到后验概率最大的类中，等价于0-1损失函数下期望风险最小化。</p>
<p>假设联合概率分布为<span class="math">\(P(X,Y)\)</span>, 对于给定的决策函数<span class="math">\(f\)</span>，期望风险
</p>
<div class="math">$$R_{exp}(f) = E_{X}\sum\limits_{k=1}{K}\lbrack L(c_{k}, f(X))\rbrack P(c_{k}|X)
$$</div>
<p>
要使得期望风险最小，于是
</p>
<div class="math">$$\begin{aligned}
f(x) =&amp; \arg \min\limits_{c_{k}}P(y \neq c_{k}|X=x)
=&amp; \arg \min\limits_{c_{k}}{1-P(y=c_{k}|X=x)} \\
=&amp; \arg \max\limits_{c_{k}}P(c_{k}|X=x)
\end{aligned}$$</div>
<h2>朴素贝叶斯方法的参数估计</h2>
<h3>极大似然估计</h3>
<div class="math">$$P(Y=c_{k}) = \frac{freq(y=c_{k})}{N}$$</div>
<p>
其中<span class="math">\(freq\)</span>为频数函数。
</p>
<div class="math">$$P(X^(j)=a_{jl}|c_{k})=\frac{freq(x^(j)=a_{jl},c_{k})}{freq(c_{k})}$$</div>
<p>
其中<span class="math">\(a_{jl}\)</span>表示第j个特征可能取得的第l个值。
将上述两式带入到朴素贝叶斯分类器模型就可以得到极大似然估计。</p>
<h4>朴素贝叶斯方法的极大似然估计算法</h4>
<p>naive Bayes algorithm 朴素贝叶斯算法</p>
<blockquote>
<p>输入: 训练数据集<span class="math">\(T=\{(x_{1},y{1}), \cdots, (x_{N}, y_{N})\}\)</span>,其中<span class="math">\(x_{i}=(x_{i}^(1), \cdots, x_{i}^(n))^{T}\)</span>, <span class="math">\(x_{i}^{j}\)</span>是第i个样本的第j个特征, <span class="math">\(x_{i}^(j) \in {a_{j1}, \cdots, a_{jS_{j}}}\)</span>, <span class="math">\(a_{jh}是第j个特征可能取得的第l个值, $y_{i} \in \{c_{1}, \cdots, c_{K}\}\)</span>; 实例<span class="math">\(x\)</span>.</p>
<p>输出: 实例x的分类</p>
<p>(1) 计算先验概率和条件概率</p>
<p>
<div class="math">$$P(c_{k})$$</div>
</p>
<p>
<div class="math">$$P(a_{jh}|c_{k})$$</div>
</p>
<p>(2) 对于给定的实例, 计算</p>
<p>
<div class="math">$$P(c_{k})\prod\limits_{j=1}{n}P(x^(j)|c_{k})$$</div>
</p>
<p>(3) 取上面结果最大的类作为实例<span class="math">\(x\)</span>的类输出。</p>
</blockquote>
<h4>朴素贝叶斯方法的极大似然估计的python实现</h4>
<p><a href="https://github.com/forin-xyz/statistical-learning-method/blob/master/naive_bayes_MLE.py" title="github">朴素贝叶斯-极大似然估计</a></p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">naive_bayes_MLE_train</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xl</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">yl</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="kp">shape</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xl</span><span class="p">:</span>
        <span class="n">xl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">yl</span><span class="p">:</span>
        <span class="n">yl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yl</span><span class="p">)</span>
    <span class="c"># 统计y各个结果出现的频次</span>
    <span class="n">yf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([(</span><span class="n">y</span><span class="o">==</span><span class="n">ylit</span><span class="p">)</span><span class="o">.</span><span class="kp">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">ylit</span> <span class="ow">in</span> <span class="n">yl</span><span class="p">])</span>
    <span class="c"># 统计x^j,y出现的频次</span>
    <span class="n">xfmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">zeros</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="kp">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">xlit</span><span class="p">)</span> <span class="k">for</span> <span class="n">xlit</span> <span class="ow">in</span> <span class="n">xl</span><span class="p">])))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">yl</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">xl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
            <span class="n">xfmatrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c"># 计算出各个类后验概率的分母</span>
    <span class="n">py</span> <span class="o">=</span> <span class="n">yf</span><span class="o">/</span><span class="n">N</span>
    <span class="n">pxmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([</span><span class="n">xfmatrix</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">yf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)])</span>
    <span class="n">pyx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">zeros</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">pkx</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">pkx</span> <span class="o">*=</span> <span class="n">pxmatrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">xl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])]</span>
        <span class="n">pyx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">pkx</span>
    <span class="k">return</span> <span class="n">yl</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="kp">argmax</span><span class="p">(</span><span class="n">pyx</span><span class="p">)]</span>

<span class="c"># 测试</span>

<span class="k">def</span> <span class="nf">test_naive_bayes_MLE_train</span><span class="p">():</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">]</span>
        <span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
         <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">]</span>
    <span class="n">yo</span> <span class="o">=</span> <span class="n">naive_bayes_MLE_train</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">yo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;test naive_bayes_MLE_train successed!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;test naive_bayes_MLE_train failed!&#39;</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_naive_bayes_MLE_train</span><span class="p">()</span>
</pre></div>


<h3>贝叶斯估计</h3>
<p>贝叶斯估计等价于在随机变量各个取值的频数上赋予一个正数</p>
<div class="math">$$\lambda$$</div>
<p>.</p>
<div class="math">$$P_{\lambda}(X^(j)=a_{jl}|c_{k})=\frac{freq(x^(j)=a_{jl},c_{k})+\lambda}{freq(c_{k})+S_{j}\lambda}$$</div>
<p>
其中<span class="math">\(S_{j}\)</span>表示第j个特征可能取值的集合的元素个数。
</p>
<div class="math">$$P_{\lambda}(Y=c_{k}) = \frac{freq(y=c_{k})+\lambda}{N+K\lambda}$$</div>
<h4>朴素贝叶斯方法的贝叶斯估计的python实现</h4>
<p><a href="https://github.com/forin-xyz/statistical-learning-method/blob/master/naive_bayes_BE.py" title="github">朴素贝叶斯-贝叶斯估计</a></p>
<div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">贝叶斯方法的贝叶斯估计实现</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">naive_bayes_BE_train</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xl</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">yl</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">lambdas</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="kp">shape</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xl</span><span class="p">:</span>
        <span class="n">xl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">yl</span><span class="p">:</span>
        <span class="n">yl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yl</span><span class="p">)</span>
    <span class="c"># 统计y各个结果出现的频次</span>
    <span class="n">yf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([(</span><span class="n">y</span><span class="o">==</span><span class="n">ylit</span><span class="p">)</span><span class="o">.</span><span class="kp">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">ylit</span> <span class="ow">in</span> <span class="n">yl</span><span class="p">])</span>
    <span class="c"># 统计x^j,y出现的频次</span>
    <span class="n">xfmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">zeros</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="kp">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">xlit</span><span class="p">)</span> <span class="k">for</span> <span class="n">xlit</span> <span class="ow">in</span> <span class="n">xl</span><span class="p">])))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">yl</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">xl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
            <span class="n">xfmatrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c"># 计算出各个类后验概率的分母</span>
    <span class="n">py</span> <span class="o">=</span> <span class="p">(</span><span class="n">yf</span> <span class="o">+</span> <span class="n">lambdas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="n">K</span><span class="o">*</span><span class="n">lambdas</span><span class="p">)</span>
    <span class="n">pxmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([[(</span><span class="n">xfmatrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">+</span><span class="n">lambdas</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">yf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xl</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">lambdas</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)])</span>
    <span class="n">pyx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">zeros</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">pkx</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">pkx</span> <span class="o">*=</span> <span class="n">pxmatrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">xl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])]</span>
        <span class="n">pyx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">pkx</span>
    <span class="k">return</span> <span class="n">yl</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="kp">argmax</span><span class="p">(</span><span class="n">pyx</span><span class="p">)]</span>


<span class="c"># 测试</span>

<span class="k">def</span> <span class="nf">test_naive_bayes_BE_train</span><span class="p">():</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">]</span>
        <span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
         <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">]</span>
    <span class="n">yo</span> <span class="o">=</span> <span class="n">naive_bayes_BE_train</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lambdas</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">yo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;test naive_bayes_BE_train successed!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;test naive_bayes_BE_train failed!&#39;</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_naive_bayes_BE_train</span><span class="p">()</span>
</pre></div>


<h2>朴素贝叶斯方法的应用</h2>
<h3>垃圾邮件过滤器</h3>
<blockquote>
<p>一个特定的单词组{d1, d2, d3, ..., dn}, 一个可用的邮件库, 统计每个邮件中对应单词出现与否以及是否是垃圾邮件,这样就得到一个训练集</p>
<p>对于未知的一份邮件, 就可以采用朴素贝叶斯方法对邮件是否是垃圾邮件进行判断</p>
<p>这里假设在给定的分类下每个单词出现与否与其他单词无关，虽然这和实际情况有点儿出入，但是它的预测效果依然不错。</p>
</blockquote>
<h3>中文分词</h3>
<h3>特征条件独立分布的影响</h3>
<p>这一假设使得朴素贝叶斯方法变得简单，但是在有些时候会牺牲一些分类正确性。</p>
<h3>更多</h3>
<p>如果假设特征的各个维度之间存在一定的概率依存关系，模型就编程了贝叶斯网络。</p>
<h2>中英文对照</h2>
<p>朴素贝叶斯方法 Naive Bayesian Method</p>
<p>类标记 class label</p>
<p>贝叶斯定理 bayes theorem</p>
<p>贝叶斯公式 Bayes Rule</p>
<p>先验概率 Prior Probability</p>
<p>后验概率 Posterior Probability</p>
<p>极大似然估计 Maximum Likelihood Estimation, ELM</p>
<p>贝叶斯估计 Bayesian Estimation</p>
<p>拉普拉斯平滑 Laplace smoothing</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="http://forin-xyz.github.io/output/2016/02/du-shu-bi-ji-2-cong-gan-zhi-ji-dao-zhi-chi-xiang-liang-ji.html" rel="bookmark"
                           title="Permalink to 《统计学习方法》读书笔记2-从感知机到支持向量机，含python源码">《统计学习方法》读书笔记2-从感知机到支持向量机，含python源码</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-02-18T23:00:00+08:00">
                发表于: 2016年02月18日 星期四
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="http://forin-xyz.github.io/output/author/forin-xyz.html">forin-xyz</a>
        </address>
<p>In <a href="http://forin-xyz.github.io/output/category/ji-qi-xue-xi.html">机器学习</a>.</p>
<p>tags: <a href="http://forin-xyz.github.io/output/tag/ji-qi-xue-xi.html">机器学习</a> <a href="http://forin-xyz.github.io/output/tag/gan-zhi-ji.html">感知机</a> <a href="http://forin-xyz.github.io/output/tag/perceptron.html">perceptron</a> <a href="http://forin-xyz.github.io/output/tag/zhi-chi-xiang-liang-ji.html">支持向量机</a> <a href="http://forin-xyz.github.io/output/tag/super-vector-machines.html">super vector machines</a> <a href="http://forin-xyz.github.io/output/tag/svm.html">SVM</a> <a href="http://forin-xyz.github.io/output/tag/python.html">python</a> <a href="http://forin-xyz.github.io/output/tag/ji-suan-ji-ke-xue.html">计算机科学</a> <a href="http://forin-xyz.github.io/output/tag/shu-xue-yuan-li.html">数学原理</a> <a href="http://forin-xyz.github.io/output/tag/du-shu-bi-ji.html">读书笔记</a> </p>
</footer><!-- /.post-info -->                <p>感知机(perceptron)是二类分类的线性分类模型(linear classfication model)，对应于一个特征空间(feature space)中的一个将实例划分为正负两类的分离超平面(separating hyperplane)。可以使用梯度下降法(gradient descent)对感知机模型的损失函数进行极小化求出模型参数。支持向量机(support vector machines, SVM)也是二类分类模型，线性支持向量机(linear support vector machine)与感知机(perceptron)不同在于其使间隔最大化。通过核技巧(kernel trick)以及软间隔最大化(soft margin maximization),可以学习非线性支持向量机(non-linear support vector machine)。支持向量机的学习算法就是求解凸二次规划的最优化算法。</p>
                <a class="readmore" href="http://forin-xyz.github.io/output/2016/02/du-shu-bi-ji-2-cong-gan-zhi-ji-dao-zhi-chi-xiang-liang-ji.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
                </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="http://forin-xyz.github.io/tutorial.html">我的导航</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="http://weibo.com/u/1756830393">微博</a></li>
                            <li><a href="http://github.com/forin-xyz">github</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
        </footer><!-- /#contentinfo -->

</body>
</html>